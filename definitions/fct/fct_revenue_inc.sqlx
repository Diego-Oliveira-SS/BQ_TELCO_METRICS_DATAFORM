config {
  type: "incremental",
  uniqueKey: ["ID_FATURA"],
  tags: ["fact"],
  database: "telco-metrics-473116",
  schema: "tm_analytics",
  bigquery: {
    partitionBy: "_CUT_DT",          /* _CUT_DT já é DATE */
    clusterBy: ["ID_CLIENTE"]
  }
}

/* Base: faturamento + pagamentos com status e dias de atraso */
WITH base AS (
  SELECT
    b.ID_FATURA,
    b.ID_CLIENTE,
    b.DT_VENCIMENTO,
    b.VALOR_BASE,
    p.DT_PAGAMENTO,
    p.VALOR_PAGO,
    p.METODO_PAGAMENTO,
    CASE
      WHEN p.ID_PAGAMENTO IS NOT NULL THEN 'PAGO'
      WHEN CURRENT_DATE() > b.DT_VENCIMENTO THEN 'EM_ATRASO'
      ELSE 'EM_ABERTO'
    END AS STATUS_PAGAMENTO,
    CASE
      WHEN p.DT_PAGAMENTO IS NOT NULL THEN DATE_DIFF(p.DT_PAGAMENTO, b.DT_VENCIMENTO, DAY)
      WHEN CURRENT_DATE() > b.DT_VENCIMENTO THEN DATE_DIFF(CURRENT_DATE(), b.DT_VENCIMENTO, DAY)
      ELSE 0
    END AS DIAS_ATRASO,

    /* Data de corte para particionar/filtrar incremental: mais recente entre vencimento e pagamento */
    GREATEST(
      DATE(b.DT_VENCIMENTO),
      DATE(IFNULL(p.DT_PAGAMENTO, b.DT_VENCIMENTO))
    ) AS _CUT_DT
  FROM ${ref("stg_billing")}  b
  LEFT JOIN ${ref("stg_payments")} p
    ON b.ID_FATURA = p.ID_FATURA
)

/* 1º run: carrega tudo. Runs incrementais: só últimos 3 dias (ajuste conforme sua necessidade) */
SELECT * FROM base
${when(
  incremental(),
  "WHERE _CUT_DT >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 DAY)"
)}
