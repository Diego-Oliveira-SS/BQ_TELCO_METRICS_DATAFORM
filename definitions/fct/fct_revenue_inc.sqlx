config {
  type: "incremental",
  uniqueKey: ["ID_FATURA"],                 /* chave natural da fatura */
  tags: ["fact"],
  bigquery: {
    partitionBy: "DATE(_CUT_DT)",         /* partição por data de corte */
    clusterBy: ["ID_CLIENTE"]             /* clustering útil p/ consultas por cliente */
  }
}

/* Base: faturamento + pagamentos com status e dias de atraso */
WITH base AS (
  SELECT
    b.ID_FATURA,
    b.ID_CLIENTE,
    b.DT_VENCIMENTO,
    b.VALOR_BASE,
    p.DT_PAGAMENTO,
    p.VALOR_PAGO,
    p.FORMA_PAGAMENTO,
    CASE
      WHEN p.ID_PAGAMENTO IS NOT NULL THEN 'PAGO'
      WHEN CURRENT_DATE() > b.DT_VENCIMENTO THEN 'EM_ATRASO'
      ELSE 'EM_ABERTO'
    END AS STATUS_PAGAMENTO,
    CASE
      WHEN p.DT_PAGAMENTO IS NOT NULL THEN DATE_DIFF(p.DT_PAGAMENTO, b.DT_VENCIMENTO, DAY)
      WHEN CURRENT_DATE() > b.DT_VENCIMENTO THEN DATE_DIFF(CURRENT_DATE(), b.DT_VENCIMENTO, DAY)
      ELSE 0
    END AS DIAS_ATRASO,

    /* Data de corte para particionar/filtrar incremental:
       usa a mais recente entre vencimento e pagamento */
    GREATEST(
      DATE(b.DT_VENCIMENTO),
      DATE(IFNULL(p.DT_PAGAMENTO, b.DT_VENCIMENTO))
    ) AS _CUT_DT
  FROM ${ref("stg_billing")}  b
  LEFT JOIN ${ref("stg_payments")} p
    ON b.ID_FATURA = p.ID_FATURA
)

SELECT * FROM base
${when(
  incremental(),
  "WHERE DATE(_CUT_DT) >= (SELECT IFNULL(DATE_SUB(MAX(DATE(_CUT_DT)), INTERVAL 3 DAY), DATE '1970-01-01') FROM " + self() + ")"
)}
